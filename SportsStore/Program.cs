/*  The Program.cs file is used to configure the ASP.NET Core application.
*/
using Microsoft.EntityFrameworkCore;
using SportsStore.Models;

var builder = WebApplication.CreateBuilder(args);

/*  The builder.Services property is used to set up objects, known as services, that can be used throughout
the application and that are accessed through a DI.
    The AddControllersWithViews method sets up the shared objects required by applications
using the MVC Framework and the Razor view engine.
    The AddScoped method creates a service where each HTTP request gets its own repository object, which
is the way that Entity Framework Core is typically used.
*/
builder.Services.AddControllersWithViews();
builder.Services.AddDbContext<StoreDbContext>(options => {
    options.UseSqlServer(builder.Configuration["ConnectionStrings:SportsStoreConnection"]);
});
builder.Services.AddScoped<IStoreRepository, EFStoreRepository>();
/*  For variety, let's use Razor Pages application framework to implement shopping cart functionality.
    While Razor Pages are part of the standard ASP.NET Core project template, explicitly calling the 
`AddRazorPages` method sets up the services used by Razor Pages, and the `MapRazorPages` method
registers Razor Pages as endpoints that the URL routing system can use to handle requests.
*/
builder.Services.AddRazorPages();

var app = builder.Build();

/*  ASP.NET Core receives HTTP requests and passes them along a request pipeline, which is populated
with middleware components registered using the app property. Each middleware component is able to
inspect requests, modify them, generate a response, or modify the responses that other components have
produced. 
    The UseStaticFiles method enables support for serving static content from the wwwroot folder and
will be created later in the chapter
*/
app.UseStaticFiles();

/*  I can create URLs that are more appealing to user by creating a scheme that follows the pattern of composable
URLs (e.g, "http://localhost/Products/Page2" instead of default "http://localhost/?productPage=2"). The ASP.NET Core routing 
feature makes it easy to change the URL scheme in an application.
    Following alterations are required to change the URL schemes for product pagination and filtering them by category. 
    ASP.NET Core and the routing function are tightly integrated, so the application automatically reflects a change like 
this in the URLs used by the application, including those generated by tag helpers like the one I use to generate the
page navigation links. This ensures that all the URLs in the application are consistent.
*/
app.MapControllerRoute("catpage", "{category}/Page{productPage:int}", new { Controler = "Home", action = "Index"});
app.MapControllerRoute("page", "Page{productPage:int}", new { Controller = "Home", action = "Index", productPage = 1});
app.MapControllerRoute("category", "{category}", new { Controller = "Home", action = "Index", productPage = 1});
app.MapControllerRoute("pagination", "Products/Page{productPage}", 
    new { Controller = "Home", action = "Index", productPage = 1 });

/*  One especially important middleware component provides the endpoint routing feature, which
matches HTTP requests to the application features—known as endpoints—able to produce responses for
them.  
    The endpoint routing feature is added to the request
pipeline automatically, and the MapDefaultControllerRoute registers the MVC Framework as a source of
endpoints using a default convention for mapping requests to classes and methods.
*/
app.MapDefaultControllerRoute();
app.MapRazorPages();
/*  To perform initial migration and populate database with some sample data 
*/
// SeedData.EnsurePopulated(app);

app.Run();